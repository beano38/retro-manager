import time
import logging
import os
import shutil
import xml.etree.cElementTree as ET

import xmltodict
import requests
from bs4 import BeautifulSoup

from general import Arcade

TIME_STAMP = time.strftime(" %Y%m%d")

LOG_FILE = "arcade.log"
LOG_STAMP = time.strftime("%Y-%m-%d %H:%M:%S")
LOG_FORMAT = logging.Formatter("[{}] [%(levelname)s] [%(name)s] : %(message)s".format(LOG_STAMP))

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

file_handler = logging.FileHandler(LOG_FILE)
file_handler.setLevel(logging.DEBUG)
file_handler.setFormatter(LOG_FORMAT)

stream_handler = logging.StreamHandler()
stream_handler.setLevel(logging.INFO)
stream_handler.setFormatter(LOG_FORMAT)

# logger.addHandler(file_handler)
logger.addHandler(stream_handler)


class Databases(Arcade):

    def __init__(self, system):
        Arcade.__init__(self)

        self.system = system
        # self.db_path = os.path.join(self.hs_path, "Databases", self.system)

    def read_system_xml(self, db="hyperspin"):
        """
        "read_system_xml" Method returns info in a dictionary from the
        selected system's database

        Args:
            self
            db(required, default = HyperSpin) = name of XML to read

        Returns:
            List of Dictionaries for system header and system roms

        Raises:
            None
        """
        if db == "hyperspin":
            xml = os.path.join(self.db_path, self.system + ".xml")
        else:
            xml = db

        msg = "Extracting ROM info from {} . . .".format(self.system)
        logger.info(msg)

        tree = ET.parse(xml)
        doc = tree.getroot()

        # Read Header
        system = {}
        for header in doc.iter("header"):
            for dat in header.iter():
                system[dat.tag] = dat.text
        # Iterate thru the ROMs
        rom = {}
        roms = []
        for game in doc.iter('game'):
            rom['name'] = game.get('name')
            rom['image'] = game.get('image')
            rom['index'] = game.get('index')
            rom['rom'] = False
            rom['artwork1'] = False
            rom['artwork2'] = False
            rom['artwork3'] = False
            rom['artwork4'] = False
            rom['wheel'] = False
            rom['video'] = False
            rom['theme'] = False

            for dat in game.iter():
                rom[dat.tag] = dat.text
            roms.append(dict(rom))

        for rom in roms:
            if rom["crc"]:
                rom["crc"] = rom["crc"].zfill(8).upper()

        return system, roms

    def write_rom_xml(self, games, xml, list_name=None):
        """
        "write_rom_xml" Method creates a database that is commonly used by RocketLauncher and HyperSpin,
        can be used to create the main or genre databases

        Args:
            games(required):  dictionary of games with info to load into the XML
            xml(required): path and name of XML file to write to
            list_name(required, default = System Name):  Name of the db, could be genre name

        Returns:
            None

        Raises:
            None
        """
        if not list_name:
            list_name = self.system
        root = ET.Element("menu")
        header = ET.SubElement(root, "header")
        ET.SubElement(header, "list_name").text = list_name
        ET.SubElement(header, "lastlistupdate").text = time.strftime("%Y%m%d")
        ET.SubElement(header, "listversion").text = "Final"
        ET.SubElement(header, "exporterversion").text = "Generated by retro-manager, Ben Elder"

        for rom in games:
            game = ET.SubElement(root, "game", name=rom["name"], index="", image="")
            if "description" in rom:
                ET.SubElement(game, "description").text = rom["description"]
            else:
                ET.SubElement(game, "description").text = rom["name"]
            if "cloneof" in rom:
                ET.SubElement(game, "cloneof").text = rom["cloneof"]
            else:
                ET.SubElement(game, "cloneof").text = ""
            if "crc" in rom:
                ET.SubElement(game, "crc").text = rom["crc"]
            else:
                ET.SubElement(game, "crc").text = ""
            if "manufacturer" in rom:
                ET.SubElement(game, "manufacturer").text = rom["manufacturer"]
            else:
                ET.SubElement(game, "manufacturer").text = ""
            if "year" in rom:
                ET.SubElement(game, "year").text = rom["year"]
            else:
                ET.SubElement(game, "year").text = ""
            if "genre" in rom:
                ET.SubElement(game, "genre").text = rom["genre"]
            else:
                ET.SubElement(game, "genre").text = ""
            if "rating" in rom:
                ET.SubElement(game, "rating").text = rom["rating"]
            else:
                ET.SubElement(game, "rating").text = ""
            if "enabled" in rom:
                ET.SubElement(game, "enabled").text = rom["enabled"]
            else:
                ET.SubElement(game, "enabled").text = "enabled"
        pretty = self.prettify(root)
        with open(xml, mode="w") as xml:
            xml.write(pretty)

    def audit(self, files_to_audit, db, audit_type="rom"):
        """
        "audit" Method audits folder and matches the type of to the database

        Args:
            files_to_audit(required):  directory path to the folder to audit
            db(required): path and name of XML database
            audit_type(required, default = rom):  Type of Audit - ROM, Artwork, etc

        Returns:
            Dictionary of ROM names with audit results - True/False

        Raises:
            None
        """
        system, roms = self.read_system_xml(db)
        have = os.listdir(files_to_audit)
        for fname in have:
            for rom in roms:
                if rom["name"] == os.path.splitext(fname)[0]:
                    rom[audit_type] = True

        return roms


class HyperList(Arcade):

    def __init__(self, system):
        Arcade.__init__(self)

        self.system = system

    def _get_hyperlist(self):
        """
        "get_hyperlist" Method downloads the HTML file from the URL for later use and
        returns a dictionary with info for the specified system

        Args:
            self

        Returns:
            parsed dictionary from the URL for the specified system

        Raises:
            None
        """
        url = "http://hyperlist.hyperspin-fe.com/"

        hyper_list_html = os.path.join(self.temp_path, "hyperlist" + TIME_STAMP + ".html")

        if os.path.exists(hyper_list_html):
            msg = "Using cached version of {}. The cache is good for one day".format(url)
            logger.info(msg)
            with open(hyper_list_html, "r") as data:
                soup = BeautifulSoup(data, "html.parser")
        else:
            msg = "Saving {} version for later use".format(url)
            logger.info(msg)
            r = requests.get(url)
            with open(hyper_list_html, "w") as data:
                data.write(r.text)
            soup = BeautifulSoup(r.text, "html.parser")

        table = soup.find_all("table", attrs={"class": "tborder"})
        table = table[1]
        tbody = table.find('tbody')

        rows = tbody.find_all('tr')
        hyper_list = []
        hl = {}
        for row in rows:
            cols = row.find_all('td')
            hl["name"] = cols[0].text.strip()
            hl["count"] = cols[1].text.strip()
            hl["version"] = cols[2].text.strip()
            hl["last_update"] = cols[3].text.strip()
            hl["who"] = cols[4].text.strip()

            downloads = cols[5]
            links = downloads.find_all("a", href=True)
            if len(links) > 0:
                hl["link"] = url + links[0]["href"]
            else:
                hl["link"] = ""

            hyper_list.append(dict(hl))

        hyper_list_info = None

        for i in hyper_list:
            if self.system == i["name"]:
                hyper_list_info = i

        return hyper_list_info

    def _download_db(self):
        """
        "_download_db" Internal helper method that reads the hyperlist link from _get_hyperlist and writes an XML
        database commonly used by RocketLauncher and HyperSpin

        Args:
            self

        Returns:
            True/False to use as error handling in other methods

        Raises:
            None
        """
        if not os.path.exists(self.db_path):
            os.makedirs(self.db_path)
        db_path = os.path.join(self.db_path, self.system + ".xml")
        try:
            url = self._get_hyperlist()["link"]
            response = requests.get(url)
            if response.status_code == 200:
                with open(db_path, mode="wb") as xml:
                    xml.write(response.content)
                return True
            else:
                return False
        except Exception as e:
            logger.debug(e)
            return False

    def _update_db(self):
        """
        "_update_db" Internal helper method that reads the hyperlist link from _get_hyperlist and writes an XML
        database commonly used by RocketLauncher and HyperSpin if the list has been updated from the current.
        This should not be used any longer since HyperSpin does not update update the HyperList site any longer.

        Args:
            self

        Returns:
            None

        Raises:
            None
        """
        src = os.path.join(self.db_path, self.system + ".xml")
        dst = os.path.join(self.db_path, self.system + "_backup_" + TIME_STAMP + ".xml")
        try:
            hs = Databases(self.system)
            system, roms = hs.read_system_xml()

            if system["lastlistupdate"] == self._get_hyperlist()["last_update"]:
                msg = "{} is up to date with HyperList".format(self.system)
                logger.info(msg)
            else:
                msg = "Downloading updated HyperList database for {}".format(self.system)
                logger.info(msg)
                shutil.move(src, dst)
                self._download_db()

        except:
            if os.path.isfile(self.system + ".xml"):
                print("found {} XML Database".format(self.system))
            else:
                msg = "HyperList does not have the {} database".format(self.system)
                logger.info(msg)


class NoIntro(Arcade):

    def __init__(self, system):
        Arcade.__init__(self)
        self.system = system

    def read_database(self):
        """
        "read_database" Reads the No Intro XML based databases and sorts the information into a dictionary of
        values to be used to create a RocketLauncher Database.

        Args:
            self

        Returns:
            Dictionary of ROM names with descriptive info

        Raises:
            None
        """
        root_path = os.path.join(self.clrmamepro, "datfiles", "NoIntro")
        files = os.listdir(root_path)
        from models.system import System
        platform = System(self.system)
        db = ""
        for fname in files:
            no_intro_name = fname.split(" (")
            if no_intro_name[0] == platform.nointro_db:
                db = os.path.join(root_path, fname)
                msg = "Using the database found at {}".format(db)
                logger.info(msg)

        with open(db, mode="r") as fd:
            doc = xmltodict.parse(fd.read())

        output = {}
        roms = []
        data = doc["datafile"]["game"]
        for rom_info in data:
            output["name"] = rom_info["@name"]
            output["crc"] = rom_info["rom"]["@crc"].zfill(8).upper()
            output["md5"] = rom_info["rom"]["@md5"]
            output["sha1"] = rom_info["rom"]["@sha1"]
            roms.append(dict(output))

        languages = ['Cs', 'Da', 'De', 'El', 'En', 'Es', 'Fi', 'Fr', 'Hu', 'It', 'Ja', 'Ko', 'Nl', 'No', 'Pl', 'Pt',
                     'Ru', 'Sv', 'Tr']
        regions = ['Asia', 'Australia', 'Brazil', 'Canada', 'China', 'Denmark', 'Europe', 'Finland', 'France',
                   'Germany', 'Greece', 'Hong Kong', 'Italy', 'Japan', 'Korea', 'Mexico', 'Netherlands', 'Norway',
                   'Russia', 'Spain', 'Sweden', 'Taiwan', 'USA', 'Unknown', 'World']
        bad_dump = "[b]"
        bios = "[BIOS]"

        for rom in roms:
            temp1 = rom["name"].replace(bad_dump, "(b)")
            temp2 = temp1.replace(")", "")
            rom_list = temp2.split(" (")
            rom["short_desc"] = rom_list[0]
            if bios in rom_list[0]:
                rom["bios"] = True
            if len(rom_list[1:]) > 1:
                for i in rom_list[1:]:
                    if i == "b":
                        rom["bad_dump"] = True
                    elif i in regions:
                        rom["region"] = i
                    elif i == "Demo":
                        rom["demo"] = True
                    elif "Kiosk" in i:
                        rom["Kiosk"] = True
                    elif i == "Unl":
                        rom["unl"] = True
                    elif "Rev" in i:
                        rom["rev"] = i
                    elif "NDSi Enhanced" in i:
                        rom["NDSi Enhanced"] = True
                    elif "SGB Enhanced" in i:
                        rom["SGB Enhanced"] = True
                    elif "GB Compatible" in i:
                        rom["GB Compatible"] = True
                    elif "Wii Virtual Console" in i:
                        rom["Wii Virtual Console"] = True
                    elif "iQue" in i:
                        rom["iQue"] = True
                    elif "Proto" in i:
                        rom["prototype"] = True
                    elif "Beta" in i:
                        rom["beta"] = True
                    elif i in languages:
                        rom["language"] = [i]
                    elif "," in i:
                        stuff = [x.strip() for x in i.split(',')]  # Split the string and remove whitespace
                        for j in stuff:
                            if j in languages:
                                rom["language"] = stuff
                            elif j in regions:
                                rom["region"] = stuff
            elif len(rom_list[1:]) == 1:
                if "," in rom_list[1]:
                    stuff = rom_list[1].split(", ")
                    if stuff[0] in regions:
                        rom["region"] = stuff
                elif rom_list[1] in regions:
                    rom["region"] = rom_list[1]
        return roms

    def create_db_from_no_intro(self,
                                roms="",
                                regions=("World", "USA", "Europe"),
                                unlicensed=True,
                                prototype=True,
                                beta=True,
                                include_bios=False,
                                include_bad_dumps=False,
                                xml=None
                                ):
        if not roms:
            roms = self.read_database()

        msg = "Found {} games in the {} No Intro database".format(len(roms), self.system)
        logger.info(msg)

        if not include_bios:
            roms = [rom for rom in roms if not "bios" in rom]

        for rom in roms:
            if "region" in rom and type(rom["region"]) is list:
                for i in rom["region"]:
                    if i in regions:
                        rom["description"] = "{} ({})".format(rom["short_desc"], " ,".join(rom["region"]))
            if "region" in rom and rom["region"] in regions:
                if "region" in rom:
                    rom["description"] = "{} ({})".format(rom["short_desc"], rom["region"])
                if unlicensed and "unl" in rom:
                    rom["description"] = "{} (Unl)".format(rom["description"])
                if prototype and "prototype" in rom:
                    rom["description"] = "{} (Proto)".format(rom["description"])
                if beta and "beta" in rom:
                    rom["description"] = "{} (Beta)".format(rom["description"])
                if include_bios and "bios" in rom:
                    rom["description"] = "{} [BIOS]".format(rom["description"])
                if include_bad_dumps and "bad_dump" in rom:
                    rom["description"] = "{} [b]".format(rom["description"])

        build = [rom for rom in roms if "description" in rom]
        print(len(build))

        # Sort by World, USA, Europe

        # Filter out duplicate names by short description
        all_roms = []
        final_roms = []
        for rom in build:
            description = rom["short_desc"]
            if description not in all_roms:
                all_roms.append(description)
                final_roms.append(dict(rom))

        msg = "Writing {} to the RocketLauncher database".format(len(final_roms))
        logger.info(msg)

        if not xml:
            xml = "{}.xml".format(self.system)
        sys_db = Databases(self.system)
        sys_db.write_rom_xml(final_roms, xml)


class EmuMovies(Arcade):
    def __init__(self, system):
        Arcade.__init__(self)
        self.system = system

    def create_blanks(self, extension="txt"):
        """
        "create_blanks" Method creates temporary files in a new directory in your EmuMovies folder.
        This proves useful if you would like to use EmuMovies to gather the artwork
        and movies for ROMs you may not have.

        Args:
            extension(optional, default = txt):  extension of the file

        Returns:
            None

        Raises:
            None
        """
        from models.system import System
        platform = System(system=self.system)
        db = Databases(system=self.system)
        system, roms = db.read_system_xml(
            db=os.path.join(self.rl_path, "RocketLauncherUI", "Databases", self.system, "{}.xml".format(self.system)))
        temp_dir = os.path.join(self.emu_movies_path, platform.emu_movies_name, "_Temp")
        if not os.path.isdir(temp_dir):
            os.makedirs(temp_dir)
        num = 0
        num_of_roms = len(roms)
        for rom in roms:
            if num % 100 == 0:
                msg = "Creating {} of {} temp ROM Files".format(num, num_of_roms)
                logger.info(msg)
            elif num == num_of_roms:
                msg = "Creating {} of {} temp ROM Files".format(num + 1, num_of_roms)
                logger.info(msg)
            num += 1

            tempfile = "{}.{}".format(rom["name"], extension)
            fname = os.path.join(temp_dir, tempfile)

            with open(fname, mode="w", encoding="UTF-8") as f:
                f.write("ROM Name:      {}\n".format(rom["name"]))
                f.write("Description:   {}\n".format(rom["description"]))
                f.write("Clone Of:      {}\n".format(rom["cloneof"]))
                f.write("CRC:           {}\n".format(rom["crc"]))
                f.write("Manufacturer:  {}\n".format(rom["manufacturer"]))
                f.write("Year:          {}\n".format(rom["year"]))
                f.write("Genre:         {}\n".format(rom["genre"]))
                f.write("Rating:        {}\n".format(rom["rating"]))
                f.write("Enabled:       {}".format(rom["enabled"]))


if __name__ == "__main__":
    system = "Nintendo DS"
    stuff = NoIntro(system=system)
    # xml = "Nintendo DS.xml"
    # db = Databases(system=system)
    # db.write_rom_xml(games=roms, xml=xml)

    stuff.create_db_from_no_intro()
